# 실행 컨텍스트와 호이스팅

## 🧐 실행 컨텍스트

   ### 1. 실행 컨텍스트란 무엇인가요?

   ECMAScript에서는 실행 컨텍스트를 **"실행가능한 코드를 형상화하고 구분하는 추상적인 개념"** 으로 기술하고 있으며, 이를 다시 정의한다면  **"실행 가능한 코드가 실행되기 위해 필요한 환경"** 이라고 할 수 있습니다.

   여기서 말하는 실행 가능한 코드에는 **전역 코드**, **eval 코드**, **함수 코드**가 있습니다.

   * 전역 코드 : 전역 영역에 존재하는 코드. window 아래에 정의된 함수를 말함.
   
   * eval 코드 : eval() 함수로 실행되는 코드
      * eval()은 인자로 받은 코드를 caller의 권한으로 수행하는 위험한 함수입니다. 악의적인 영향을 받았을 수 있는 문자열을 eval()로 실행한다면, 여러분의 웹페이지나 확장 프로그램의 권한으로 사용자의 기기에서 악의적인 코드를 수행하는 결과를 초래할 수 있습니다.
      * 최신 자바스크립트 인터프리터는 자바스크립트를 기계 코드로 변환합니다. 즉, 변수명의 개념이 완전히 없어지는데, eval()을 사용하면 브라우저는 기계 코드에 해당 변수가 있는지 확인하고 값을 대입하기 위해 길고 무거운 변수명 검색을 수행합니다.
      * eval()을 통해 자료형 변경 등 변수에 변화가 일어날 수 있으며, 브라우저는 이에 대응하기 위해 기계 코드를 재작성해야합니다.


   * 함수 코드 : 함수 내에 존재하는 코드

   자바스크립트 엔진이 실행 가능한 코드의 유형을 분류하는 이유는 실행 컨텍스트를 초기화하는 환경과 과정이 다르기 때문입니다.

   특히 eval 코드는 밑에서 설명할 렉시컬 환경(Lexical Environment)이 아니라 별도의 동적 환경에서 실행됩니다. 여기서는 eval의 실행 컨텍스트에 관한 설명을 제외하겠습니다.
   따라서 자동으로 생성되는 전역 영역에 존재하는 코드, 악마로 취급받는 eval()을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것뿐입니다.

   실행 컨텍스트는 실행가능한 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하며, 이를 **콜 스택에 쌓아 올렸다가 (push), 가장 위에 쌓여있는 컨텍스트와 관련있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장**합니다

   * 콜 스택 : 함수의 호출을 기록하는 자료구조로, 프로그램에서 우리가 어디에 있는지를 기본적으로 기록하는 데이터 구조입니다. **어떤 함수를 실행할 때 해당 함수의 기록을 스택 맨 위에 추가(push)하고, 함수가 결과값을 반환하면 스택에 쌓여있던 함수는 제거(pop)** 됩니다.

   * 스택 : 나중에 집어넣은 데이터가 먼저 나옵니다. 이 특징을 **LIFO**(First In First Out)라고 합니다. 데이터를 집어넣는 push, 데이터를 추출하는 pop, 맨 나중에 집어넣은 데이터를 확인하는 peek 등의 작업을 할 수 있습니다.

   * 큐 : 먼저 집어넣은 데이터가 먼저 나옵니다. 이 특징을 **FIFO**(First In First Out)라고 합니다. 데이터를 집어넣는 enqueue, 데이터를 추출하는 dequeue 등의 작업을 할 수 있습니다.

   ### 2. 실행 컨텍스트와 콜 스택

   여기서는 콜 스택에 실행 컨텍스트가 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여하는 지만 확인할 수 있으면 됩니다. 밑 코드에 대한 예제는 뒤에서 ~~(스코프체인...)~~ 더 자세히 알아보도록 하겠습니다.

   ```javascript
   01    // ------------------------ (1)
   02
   03    var a = 1;
   04
   05    function outer() {
   06       function inner() {
   07          console.log(a);
   08          var a = 3;
   09       }
   10       inner(); // ------------ (2)
   11       console.log(a)
   12    }
   13
   14    outer(); // --------------- (3)
   15    console.log(a);
   ```
   ```
                                    |--------|
                                    | inner  |
                         |--------| |--------| |--------| 
                         | outer  | | outer  | | outer  | 
   |        | |--------| |--------| |--------| |--------| |--------| |        |
   |        | | global | | global | | global | | global | | global | |        |
   |--------| |--------| |--------| |--------| |--------| |--------| |--------|

                  01       14, 05     10, 06       11         15          
   ```
   1. 01 : (1)에서 처음 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담기며, 최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화됩니다.

   2. 14 : 전역 컨테스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer() 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집하여 outer 실행 컨텍스트를 생성한 후 콜 스택에 담습니다. 콜 스택 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단하고 outer 함수 내부의 코드들을 순차로 실행합니다. 

   3. 10 : (2)에서 inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 컨텍스트 관련된 코드의 실행을 중단하고 innter 함수 내부의 코드를 순서대로 진행합니다. 

   4. 06 : inner 함수 내부에서 a 변수의 값을 출력하고 나면 inner 함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거됩니다.

   5. 11 : inner 실행 컨텍스트가 제거되어 outer 컨텍스트가 콜 스택 맨 위에 존재하게 되므로 중단했던 (2) 의 다음줄부터 실행하게 됩니다. 여기서 a변수의 값을 출력하고 나면 outer 함수의 실행이 종료되어 outer 실행 컨텍스트가 콜 스택에서 제거됩니다.

   6. 15 : 이전에 실행을 중단했던 (3) 다음 줄부터 이어 실행됩니다. a 변수를 출력하고 나면 전역 공간에 더는 실행할 코드가 남아 있지 않아 전역 컨텍스트도 제거되고, 콜 스택에는 아무것도 남지 않은 상태로 종료됩니다.

   스택 구조를 생각해보았을 때, 기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수밖에 없기 때문에 **한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점**임을 알 수 있습니다.

   이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 **환경 정보들을 수집하여 실행 컨텍스트 객체에 저장**하는데요.

   여기에 담기는 정보에는 **VariableEnvironment**, **LexicalEnvironment**, **thisBinding** 이 있습니다.

   ```
   Excution context (실행 컨텍스트)
     │
     │
     ├─ VariableEnvironment ─ EnvironmentRecord (snapshot)
     │                      ─ OuterEnvironmentReference (snapshot)       
     │
     ├─ LexicalEnvironment  ─ EnvironmentRecord
     │                      ─ OuterEnvironmentReference
     │
     └─ ThisBinding
   ```

   * VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로, 함수 실행 도중에 일어난 변경 사항은 반영되지 않고 초기 상태를 유지함.

   * LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 함수 실행 도중에 일어난 변경 사항이 실시간으로 반영됨.

   * thisBinding : 식별자가 바라봐야 할 대상 객체.

   위의 친구들은 다음 내용에서 뜯어보겠습니다.

## 🧐 변수 환경(VariableEnvironment) 컴포넌트와 렉시컬 환경(LexicalEnvironment) 컴포넌트

   실행 컨텍스트는 실행 가능한 코드가 실제로 실행되고 관리되는 영역입니다. 따라서 실행에 필요한 모든 정보를 컴포넌트 여러 개가 나누어 관리하도록 만들어져 있는데요.

   그 중에서 가장 중요한 컴포넌트는 **변수 환경(VariableEnvironment) 컴포넌트**, **렉시컬 환경(LexicalEnvironment) 컴포넌트**, **디스바인딩(ThisBinding) 컴포넌트**입니다.

   렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 타입이 같고, 실제로 with문을 사용할 떄를 제외하면 내부 값이 같으므로 똑같이 취급하여도 무리가 없습니다. 따라서 이후부터는 렉시컬 환경 컴포넌트로 통일하여 설명하겠습니다.

   (변수환경컴포넌트와 렉시컬환경컴포넌트의 차이 작성)

## 🧐 디스 바인딩(ThisBinding) 컴포넌트

   디스 바인딩(ThisBinding) 컴포넌트는 **그 함수를 호출한 객체의 참조가 저장되는 곳**입니다. 이것이 가리키는 값이 곧 해당 실맹 컨텍스트의 **this**가 됩니다. *이 부분은 밑에서 자세히 설명하겠습니다.*

## 🧐 렉시컬 환경(LexicalEnvironment) 컴포넌트
   렉시컬 환경 컴포넌트는 자바스크립트 엔진이 자바스크립트 코드를 실행하기 위해 자원을 모아 둔 곳으로, **함수 또는 블록 유효 범위 안에 있는 식별자와 그 결괏값이 저장되는 곳**입니다. 

   자바스크립트 엔진은 해당 자바스크립트 **코드의 유효 범위 안에 있는 식별자와 그 식별자가 가리키는 값을 키와 값의 쌍으로 바인드**해서 렉시컬 환경 컴포넌트에 기록합니다.

   렉시컬 환경 컴포넌트는 **환경 레코드(Environment Record)**와 **외부 렉시컬 환경 참조(Outer Lixical Environment)**로 구성되어있습니다.

   ### **환경 레코드(Environment Record)**

   유효 범위 안에 포함된 **식별자를 기록하고 실행**하는 영역입니다. 자바스크립트 엔진은 유효 범위 안의 식별자와 결괏값을 바인드해서 환경 레코드에 기록합니다.

   그리고 렉시컬 환경 안의 식별자와 그 식별자가 가리키는 값의 묶음이 실제로 저장되는 영역입니다. 이 환경 레코드는 **선언전 환경 레코드(Declarative)**, **객체 환경 레코드 (object Environment Record)**로 구성되어 있으며, 저장하는 값의 유형에 따라 쓰임새가 달라집니다.

   * 선언전 환경 레코드(Declarative Environment Record) : 이는 실제로 **함수와 변수, catch문의 식별자와 실행 결과**가 저장되는 영역입니다.

   * 객체 환경 레코드(Object Environment Record) : 선언적 환경 레코드가 식별자와 그 실행 결과를 키와 값의 쌍으로 관리하는 반면 객체 환경 레코드는 **실행 컨텍스트의 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 씁니다.** 즉, with 문의 렉시컬 환경, 전역 객체처럼 별도의 객체에 저장된 데이터는 그 객체가 가진 키와 값의 쌍을 복사해 오는 것이 아니라 **그 객체 전체의 참조를 가져와서** 객체 환경 레코드의 bindObject라는 프로퍼티에 바인드하도록 만들어져 있습니다.

   ### **외부 렉시컬 환경 참조(Outer Lixical Environment)**

   자바스크립트는 함수 안에 함수를 중첩해서 정의할 수 있는 언어이므로 자바스크립트 엔진은 유효 범위 너머의 유효 범위도 검색할 수 있어야합니다.

   외부 렉시컬 환경 참조에는 **함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조가 저장**됩니다.
   중첩된 함수 안에서 바깥 코드에 정의된 변수를 읽거나 써야 할 때, 자바스크립트 엔진은 외부 렉시컬 환경 참조를 따라 한 단계씩 렉시컬 환경을 거슬러 올라가 그 변수를 검색합니다.



## 🧐 Hoisting(호이스팅)

   environmentRecord는 코드 실행 전 컨텍스트 내부를 처음부터 끝까지 훑으며 순서대로 수집합니다. 

   각 정보들을 수집하는 과정을 마쳤더라도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태인데, 이러한 상태임에도 불구하고 자바스크립트 엔진은 이미 실행할 컨텍스트 내부에 있는 모든 식별자들을 알고 있게 됩니다.
   그렇기에 '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각해도 코드를 해석하는 데 문제될 것이 없을 것입니다.

   이 부분에서, 자바스크립트 엔진이 실제로 식별자들을 최상단으로 끌어올리지는 않지만 그렇게 간주하자!는 **호이스팅**이 등장합니다. (두둥)

   호이스팅은 코드 해석을 좀 더 수월하게 하기 위해 environment의 수집 과정을 추상화한 개념이라고 생각하시면 됩니다.

   ```javascript
   function a(x) {
      console.log(x); // (1)
      var x;
      console.log(x); // (2)
      var x = 2;
      console.log(x); // (3)
   }

   a(1);
   ```

   위의 예제 코드에서는 로그가 어떻게 찍힐까요? 호이스팅이 안 되었을 경우, 되었을 경우로 나눠 결과를 예상해보겠습니다.

   **호이스팅이 안 되었을 경우**
   
   (1)에는 함수 호출 시 1이 출력, (2)는 선언된 변수 x에 할당한 값이 없으므로 undefined가 출력, (3)은 2가 출력될 것이라 생각할 수 있습니다. 실제로 코드 실행 시 어떤 결과가 나올까요? 생각과 같을까요? *흠*

   **호이스팅이 되었을 경우**

   *!!밑에있는 예제 코드들은 자바스크립트 엔진 구동 방식을 사람의 입장에서 이해하고자 변경해놓은 코드입니다. 실제로는 이러한 변환 과정을 거치지 않으니 오해하지 마세요!!*

   ```javascript
   01    function a() {
   02       var x = 1; 
   03       console.log(x); // (1)
   04       var x; 
   05       console.log(x); // (2)
   06       var x = 2;
   07       console.log(x); // (3)
   08    }
   09
   10    a();
   ```

   위의 예제 처럼 인자들과 함께 함수를 호출한 경우의 동작을 봤을 때, arguments에 전달된 인자를 담는 것을 제외하면 밑의 예제처럼 코드 내부에서 변수를 선언한 것과 다른 점이 없으며 인자를 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이뤄진 것으로 간주할 수 있습니다.

   environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심있을 뿐이지, 각 식별자에 어떤 값이 할당될 것인지에는 관심이 없습니다. 따라서 변수나 매개변수를 호이스팅할 때 **변수명만 끌어올리고 할당 과정은 원래 그 자리에 남겨둡니다.**

   ```javascript
   01    function a(x) {
   02       var x;
   03       var x;
   04       var x;
   05    
   06       var x = 1; 
   07       console.log(x); // (1)
   08       console.log(x); // (2)
   09       var x = 2;
   10       console.log(x); // (3)
   11    }
   12
   13    a(1);
   ```

   호이스팅이 끝났으니 실제 코드를 실행할 차례입니다.

   1. 02 : 변수 x를 선언하는데, 이때 메모리에서는 저장할 공간을 미리 확보하고, 확보한 공간의 주솟값을 변수 x에 연결합니다.

   2. 03, 04 : 이미 선언된 변수 x가 있으므로 무시합니다.

   3. 06 : x에 1을 할당합니다. 숫자 1을 별도의 메모리에 담고, x와 연결된 메모리 공간에 숫자 1을 가리키는 주솟값을 입력합니다.

   4. 07, 08 : x를 출력합니다. (1), (2) 모두 1이 출력됩니다.

   5. 09 : 다시 x에 2를 할당합니다. 숫자 2를 별도의 메모리에 담고, 그 주솟값을 가진 채로 x와 연결된 메모리 공간으로 갑니다. 기존 숫자 1을 가리키는 주솟값이 들어있는데, 이것을 2의 주솟값으로 대치합니다. 이제 변수 x는 숫자 2를 가리키게 되겠죠?

   6. 10 : x를 출력합니다. (3)에서는 2가 출력되고, 이제 함수 내부의 모든 코드가 실행되었으므로 실행 컨텍스트가 콜 스택에서 제거됩니다.

   호이스팅 개념이 없었다면 (2)에서 undefined가 아닌 1이 출력된다는 것을 알 수 없었을 것입니다

   바로 밑에서는 함수 선언을 추가한 예제를 확인해보겠습니다. 

   ```javascript
   01    function a() {
   02       console.log(b); // (1)
   03       var b = "bbb";
   04       console.log(b); // (2)
   05       function b() {} 
   06       console.log(b); // (3)
   07    }
   08
   09    a();
   ```

   이 예제 친구도 출력 결과를 미리 예상해볼까요? ~~저는 틀렸습니다..~~

   **호이스팅이 안 되었을 경우**

   a 함수를 실행했을 때 (1)에는 b의 값이 없으니 에러가 나거나 undefined가 나올 것 같고, (2)는 "bbb", (3)은 b 함수가 출력될 것 같습니다.

   **호이스팅이 되었을 경우**

   a 함수를 실행하는 순간 a 함수의 실행 컨텍스트가 생성되는데 이때 변수명과 함수 선언의 정보를 위로 끌어올립니다!(호이호이스팅) 

   변수는 선언부와 할당부를 나누어 **선언부**만 끌어올리는 반면에 함수 선언은 **함수 전체**를 끌어올립니다. 

   ```javascript
   01    function a() {
   02       var b;
   03       function b() {};
   04     
   05       console.log(b); // (1)
   06       b = "bbb";
   07       console.log(b); // (2)
   08       console.log(b); // (3)
   09    }
   10
   11    a();
   ```

   수집한 변수명과 함수 선언 정보를 순서대로 끌어올리면 이와 같은 형태로 변환됩니다.

   여기서, 호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있습니다.

   ```javascript
   01    function a() {
   02       var b;
   03       var b = function b() {}; // 바로 이렇게요!
   04     
   05       console.log(b); // (1)
   06       b = "bbb";
   07       console.log(b); // (2)
   08       console.log(b); // (3)
   09    }
   10
   11    a();
   ```

   이제 실행 컨텍스트 내부의 코드를 차례대로 실행해보겠습니다.

   1. 02 : 변수 b를 선언합니다. 이때 메모리에서는 저장할 공간을 미리 확보하고, 확보한 공간의 주솟값을 변수 b에 연결합니다.

   2. 03 : 변수 b를 선언합니다. 함수 b를 선언된 변수 b에 할당하는데 이미 선언된 변수 b가 있으므로 선언 과정은 무시합니다. 함수는 별도의 메모리에 담길 것이고, 그 함수가 저장된 주솟값을 b와 연결된 공간에 저장하게되면 변수 b는 함수를 가리키게 됩니다.

   3. 05 : (1)은 변수 b에 할당된 함수 b를 출력합니다.

   4. 06 : 다시 b에 "bbb"를 할당합니다. b와 연결된 메모리 공간에는 함수가 저장된 주솟값이 담겨있었는데 이것을 "bbb"가 담긴 주솟값으로 대치합니다. 이제 b는 "nnn"를 가리키게 되겠죠?

   5. 07, 08 : (2)와 (3) 모두 "bbb" 가 출력되고, a 함수 내부의 모든 코드가 실행되었으므로 실행 컨텍스트가 콜 스택에서 제거됩니다.


## 🧐 함수 선언문과 함수 표현식

   변수 선언과 값 할당이 동시에 이뤄진 문장은 '선언부'만을 호이스팅하고, 할당 과정은 원래 자리에 남아있게 됩니다. 여기서 함수 선언문과 함수 표현식의 차이가 발생하는데요.

   바로 밑에서 함수 선언문과 함수 표현식은 어떤 친구인지, 어떠한 차이가 발생하는지 알아보겠습니다.

   ### 1. 함수 선언문 (FD.Function Declaration)

   함수 선언문은 **function 정의부만 존재하고 별도의 할당 명령이 없는 것**을 의미하며, 이는 **반드시 함수명이 정의**돼 있어야 합니다.

   ```javascript
   01    function a() { /* ... */ }
   02    a();
   ```
   1. 01 : 함수 선언문. 함수명 a가 곧 변수명.

   2. 02 : 실행 됨

   ### 2. 함수 표현식 (FE.Function Expression)

   함수 표현식은 **반드시 함수명이 정의돼 있지 않아도 됩니다**.

   함수명을 정의한 함수 표현식을 '**기명 함수 표현식**', 정의하지 않은 것을 '**익명 함수 표현식**' 이라고 부르기도 하는데 **일반적으로 함수 표현식은 익명함수 표현식**을 말합니다.

   기명 함수 표현식은 외부에서 함수명으로 함수를 호출할 수 없으며 **함수명은 오직 함수 내부에서만 접근**할 수 있습니다. 그렇다면 이 친구를 사용할 때 함수명은 어떤 용도로 쓰일까요? 

   과거에 기명 함수 표현식은 함수명이 잘 출력됐던 반면, 익명 함수 표현식은 undefined 또는 unnamed라는 값이 나왔었습니다. 이 때문에 기명 함수 표현식이 디버깅 시 어떤 함수인지 추적하기에 익명 함수 표현식보다 유리한 측면이 있었는데요. 그러나 이제는 모든 브라우저들이 익명 함수 표현식의 변수명을 함수의 name 프로퍼티에 할당하고 있습니다.

   기명 함수 표현식의 내부에서는 해당 함수로 호출하든, 해당 함수명으로 호출하든 잘 실행됩니다. 따라서 함수 내부에서 재귀함수를 호출하는 용도로 함수명을 쓸 수 있습니다. *다만, 해당 함수로 호출해도 되는 상황에서 굳이 함수명으로 호출해야 할 필요가 있을까요?*

   ```javascript
   01    var b = function() { /* ... */ }
   02    b();
   03
   04    var c = function d() { /* ... */ }
   05    c();
   06    d();
   ```

   1. 01 : (익명)함수 표현식. 변수명 b가 곧 함수명.

   2. 02 : 실행 됨

   3. 04 : (기명)함수 표현식. 변수명은 c, 함수명은 d.

   4. 05 : 실행 됨

   5. 06 : 에러

   다음 밑 예제를 통해 함수 선언문과 함수 표현식의 실질적인 차이를 알아보겠습니다.

   ```javascript
      console.log(sum(1, 2));
      console.log(multiply(3, 4));

      function sum(a, b) { // 함수 선언문
         return a + b;
      }

      var multiply = function(a, b) { // 함수 표현식
         return a + b;
      }
   ```

   실행 컨텍스트의 lexicalEnvironment는 두 가지 정보를 수집하는데, 여기서는 그중에서 environmentRecord의 정보 수집 과정 중 발생하는 호이스팅을 살펴보겠습니다.
   
   밑에서 호이스팅을 마친 최종 상태를 바로 확인해볼게요.

   ```javascript
      01    var sum = function sum(a, b) {
      02       return a + b;
      03    }
      04    var multiply;
      05
      06    console.log(sum(1, 2));
      07    console.log(multiply(3, 4));
      08   
      09    multiply = function(a, b) {
      10       return a + b;
      11    }
   ```

   함수 선언문은 함수 전체를 호이스팅한 반면, 함수 표현식은 변수 선언부만 호이스팅합니다. 함수도 하나의 값으로 취급할 수 있다는 것이 바로 이런 것이겠죠? **함수를 다른 변수에 값으로써 '할당'한 것이 곧 함수 표현식입니다.**
   
   호이스팅이 끝났으니 내부 코드들을 차례로 실행해보겠습니다.

   1. 01 : 메모리 공간을 확보하고, 확보된 공간의 주솟값을 변수 sum에 연결합니다.

   2. 04 : 또 다른 메모리 공간을 확보하고 그 공간의 주솟값을 변수 multiply에 연결합니다.

   3. 01 : 다시 sum 함수를 또 다른 메모리 공간에 저장하고, 그 주솟값을 앞에서 선언한 변수 sum의 공간에 할당합니다. 이로써 변수 sum은 sum을 바라보는 상태가 됩니다.

   4. 06 : sum을 실행하여 3을 출력합니다.

   5. 07 : 현재 multiply에는 값이 할당돼 있지 않습니다. 비어있는 대상을 함수로 여겨 실행하라고 명령한 것입니다. 따라서 'multiply is not a function'이라는 에러 메시지가 출력되며, 뒤의 09, 10 줄은 해당 07 줄의 에러로 인해 실행되지 않은 채 런타임이 종료됩니다.

   sum 함수는 선언 전에 호출해도 아무 문제 없이 실행됩니다. 어떻게 작성해도 오류를 내지 않는다는 면에서 초급자들이 조금 더 쉽게 접근할 수 있게 해주는 측면도 있지만, 반대로 큰 혼란을 일으킬 수도 있겠죠. 
   
   함수 선언문이 혼란스러운 개념이라고 말하는 이유를 바로 밑에서 설명하겠습니다.

   이런 일이 있어서는 안 되겠지만 상황을 예시로 들겠습니다.
   
   1. 혜진님이 sum 함수를 선언했습니다. 이 함수는 인자 두 개를 받아 두 인자의 합을 반환하는 단순한 함수입니다. 이 함수는 자바스크립트 파일 내의 100번째 줄에 위치합니다.

   2. 새로 입사한 휘림님이 같은 파일의 5000번째 줄에서 sum 함수를 새로 선언합니다. x, y를 받아 문자열로 "x + y = (x+y)"를 반환하는 함수입니다. 자바스크립트 응애인 휘림님은 본인이 작성한 sum 함수가 선언한 위치인 5000번째 줄 이후에만 영향을 줄 것이라며 의심 1도 없이 테스트도 하지 않고 커밋, 머지한 다음 배포까지 해버립니다. ~~대참사 흑흑~~

   전역 컨텍스트가 활성화 될 때 전역 공간에 선언된 함수들이 모두 가장 위로 끌어올려집니다. 동일한 변수명에 서로 다른 값을 할당할 경우엔 나주엥 할당한 값이 먼저 할당한 값을 덮어씌우겠죠. 따라서 코드를 실행하는 중에 **실제로 호출되는 함수는 맨 마지막에 선언된 함수** 뿐입니다. 

   혜진님이 의도했던 함수는 숫자로 된 결괏값을 반환하는 것이었는데, 실제로는 전혀 다른 문자열을 반환하게 됩니다. 여기저기서 문제를 뿜어내고 있는데 정작 문제의 원인인 휘림님이 작성한 sum 함수는 아무런 문제를 내지 않습니다.

   혜진님은 문제가 된 함수를 살펴봐도 뭐가 문제인지 도통 알 수가 없습니다. 위에서는 얼른 수정하라고 압박인데 오떤 코드가 문제인지를 어디서부터 어떻게 찾아야 할지 엄두가 안 나겠네요. ~~끔찍~~
   
   위와 같은 상황에서 혜진님과 휘림님 모두 sum 함수를 함수 표현식으로 정의했다면 괜찮았을까요? 

   5000번째 줄 이전까지는 혜진님 의도대로, 이후부터는 휘림님 의도대로 잘 동작했을 것입니다. 그 뿐만 아니라 sum 함수를 처음 선언한 100번째 줄보다 이전 줄에 sum 함수를 호출하는 코드가 있었다면 그 줄에서 바로 에러가 검출되므로 더욱 빠르고 손쉽게 디버깅 할 수 있었을 것입니다.

   극단적인 예시였죠..? 원활한 협업을 위해서는 전역공간에 함수를 선언하거나 동명의 함수를 중복 선언하는 경우는 없어야만 합니다. 전역 공간에 동명의 함수가 여럿 존재하는 상황이더라도 모든 함수가 함수 표현식으로 정의돼 있었다면 위와 같은 상황은 일어나지 않았겠죠.