# 실행 컨텍스트와 호이스팅

## 🤘 목표

-   [ ]

####

## 📄 실행 컨텍스트

실행 컨텍스트란 *실행할 코드에 제공할 환경 정보들을 모아놓은 객체*로 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.
자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데,
이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.

1. 실행 컨텍스트 개념

    실행 가능한 코드를 형상화하고 구분하는 추상적인 개념으로, 즉 **실행 가능한 자바스크립트 코드 블록이 실행되는 환경**이라고 할 수 있습니다.
    전역 코드, eval 함수, 함수 내부의 코드를 실행하는 경우가 이에 해당합니다.
    간단한 예제 코드를 통해 실행 컨텍스트를 시각적으로 보여드리도록 하겠습니다.
    주석에 주목하시기 바랍니다.

    ```javascript
    // 전역 실행 컨텍스트

    if (true) {
        console.log('실행!');
    }

    eval(
        // eval 함수 실행 컨텍스트

        '2 + 2',
    );

    function exec() {
        // 함수 실행 컨텍스트

        console.log('실행!');
    }
    ```

    ECMA Script에서는 실행 컨텍스트의 생성을 *현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 그 제어권이 해당 컨텍스트로 이동한다*고 설명합니다.
    위의 예제 코드를 다시 살펴보겠습니다.

    ```javascript
    // 전역 실행 컨텍스트 환경

    if (true) {
        console.log('실행!');
    }

    eval(
        // 👈 전역 컨텍스트와 상관없는 eval 함수 실행 코드가 실행됨! => eval 함수 컨텍스트가 스택에 들어가고 제어권 역시 넘어감
        // eval 함수 실행 컨텍스트 환경

        '2 + 2',
    );

    function exec() {
        // 👈 전역 컨텍스트와 상관없는 함수 실행 코드가 실행됨! => 함수 컨텍스트가 스택에 들어가고 제어권 역시 넘어감
        // 함수 실행 컨텍스트 환경

        console.log('실행!');
    }

    exec();
    ```

    그렇다면 여기서 말하는 제어권이란 무엇일까요?
    다른 예제 코드를 통해 제어권에 대해 살펴보겠습니다.

    ```javascript
    // 전역 실행 컨텍스트 환경

    var a = 1;

    console.log(a); // 1

    function exec() {
        // 👈 전역 컨텍스트와 상관없는 함수 실행 코드가 실행됨! => 함수 컨텍스트가 스택에 들어가고 제어권 역시 넘어감
        // 함수 실행 컨텍스트 환경
        var a = 2;

        console.log(a);
    }

    exec();
    ```

    앞서 말씀드렸듯이 전역 컨텍스트의 제어권이 함수 컨텍스트로 넘어가기 때문에 전역변수 a는 exec 함수 내에 a보다 우선적으로 적용되지 않습니다.
    물론, exec 함수 내에 a가 존재하지 않는다면 스코프 체인에 의해 전역변수 a가 출력됩니다.
    이는 이 파트의 범위를 넘어서는 것이므로 스코프 파트에서 다시 다루도록 하겠습니다.

2. 스택과 큐, 실행 컨텍스트

    본격적으로 실행 컨텍스트를 살펴보기에 앞서 자료구조인 스택과 큐의 개념을 잠시 살펴보도록 하겠습니다.
    스택은 ~~출입구가 하나뿐인 깊은 우물 같은 데이터 구조~~라고 교재에서 설명하고 있으나, 개인적으로 저는 *쌓인 책 더미 📚*라는 표현을 좋아하고 또 직관적이라고 생각하기 때문에 책 더미에 비유하도록 하겠습니다.
    먼저 a라는 책이 존재합니다. 바닥에 놓습니다.
    그 다음 b라는 책이 존재합니다. a책 위에 놓습니다.
    그 다음 c라는 책이 존재합니다. b책 위에 놓습니다.
    마지막으로 d라는 책이 존재합니다. c책 위에 놓습니다.
    책 더미가 다음과 같이 쌓였습니다.

    d (위)
    c
    b
    a (아래)

    이제 책을 읽습니다. 스택의 세계에서 ~~밑장 빼기~~는 허용되지 않으므로 a책을 읽기 위해서는 먼저 d를, 그 다음 c를, 그 다음 b를 읽어야만 합니다.
    개발자 사이에서 유명한 사이트인, '스택오버플로우'의 그 스택입니다.
    스택 오버 플로우를 설명하기 위해서는 저자의 비유인 *우물*이 좀 더 적합하긴 하겠습니다.
    책을 100권만 쌓을 수 있는 우물에 200권의 책을 쌓았다고 가정해 봅시다.
    당연히 책 더미가 우물 밖으로 우뚝 솟아나오는 것은 물론, 자칫하면 와르르 무너질 수도 있겠죠?
    많은 프로그래밍 언어들은 이처럼 스택이 넘칠 때 에러를 던집니다.
    ~~저도 재귀 호출이나, while문을 섣부르게 쓰다가 브라우저의 콜 스택을 폭파시키는 일이 빈번합니다(...)~~

    한편 큐는 ~~모두 열려있는 파이프~~를 떠올리면 된다고 교재에서 설명하고 있으나, 개인적으로 저는 *매표소 🎫*라는 표현을 좋아하고 또 직관적이라고 생각하기 때문에 매표소에 비유하도록 하겠습니다.
    물론 종류에 따라 양쪽 모두 입력과 출력이 가능한 큐도 있기 때문에 파이프가 좀 더 적합할 수 있으나 보통은 한쪽은 입력만, 다른쪽은 출력만을 담당하는 구조이기 때문에 매표소가 틀린 비유는 아닙니다.
    먼저 a라는 사람이 티켓을 사기 위해 줄을 섭니다. 매표소 창구 앞에 섭니다.
    그 다음 b라는 사람이 티켓을 사기 위해 줄을 섭니다. a사람 뒤에 섭니다.
    그 다음 c라는 사람이 티켓을 사기 위해 줄을 섭니다. b사람 뒤에 섭니다.
    그 다음 d라는 사람이 티켓을 사기 위해 줄을 섭니다. d사람 뒤에 섭니다.  
    다음과 같이 줄을 섰습니다.

    (매표소) a b c d

    이제 차례대로 티켓을 구매합니다. 큐의 세계에서 ~~새치기~~는 허용되지 않으므로 d사람이 티켓을 사기 위해서는 먼저 a사람이, 그 다음 b사람이, 그 다음 c사람이 티켓을 사야합니다.
    앞서 실행 컨텍스트를 *실행할 코드에 제공할 환경 정보들을 모아놓은 객체*라고 했습니다.
    동일한 환경에 있는 코드들을, 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성(환경 정보 객체)하고 이를 콜 스택에 쌓아 올렸다가, 가장 위에 쌓여 있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로
    전체 코드의 환경과 순서를 보장합니다.
    여기서 말하는 '동일한 환경'이란 위의 예제의 주석으로 설명한 **실행 컨텍스트 환경**을 말합니다.
    전역 실행 컨텍스트 환경이나, eval 함수 실행 컨텍스트 환경을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 *함수를 실행*하는 것뿐입니다.
    중요한 것은 *선언*이 아니고 *실행*입니다.
    위의 예제 코드의 주석에서 마치 함수가 선언될 때 컨텍스트가 구성되는 것처럼 오해할 수 있으나, 이는 시각적으로 쉽게 보여주기 위함이며, 컨텍스트는 함수가 *선언*될 때가 아니라 *실행*될 때 구성됩니다.
    ES6에서는 블록에 의해서도 새로운 실행 컨텍스트가 생성됩니다.
    const와 let 키워드로 선언한 변수가 이에 해당합니다.
    예제 코드를 통해 살펴보겠습니다.

    ```javascript
    // 전역 실행 컨텍스트 환경
    const a = 1;

    console.log(a); // 1

    function exec() {
        // 함수 실행 컨텍스트 환경
        const a = 2;

        console.log(a);

        if (true) {
            // if문 실행 컨텍스트 환경
            const a = 3;

            console.log(a);
        }
    }

    exec(); // 2 / 3
    ```

    만일 exec 함수 내의 if문 블록이 함수 실행 컨텍스트 환경의 제어권에 있었다면 if문 내에 const 키워드는 재선언이나 재할당할 수 없으므로 이미 선언돼 있다는 에러가 발생했을 것입니다.
    하지만 const와 let 키워드는 블록 실행 컨텍스트를 따르므로 위의 예제 코드는 아무런 에러가 발생하지 않습니다.

3. 실행 컨텍스트 생성 과정
